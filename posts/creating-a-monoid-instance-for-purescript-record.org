#+BEGIN_COMMENT
.. title: Creating a Monoid instance for Purescript Record
.. slug: creating-a-monoid-instance-for-purescript-record
.. date: 2018-01-03 09:00:20 UTC+01:00
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text
#+END_COMMENT

* Ok

** A rationale behind this attempt

Whyy would I want to attempt to create a monoid-like thing for records? Well, the reasoning is three-fold.
First, when playing around with Purescript, I often have these large record definitions and then I have to initialize them. I would much rather just say "This record has all fields empty, figure it out."
Second, these large records are often the heart of some state, that I update all the time, and I would much rather just do

#+BEGIN_SRC purescript
 updateFunction state update = appendRecord state update
#+END_SRC

than

#+BEGIN_SRC purescript
updateFunction state update = state {a = state.a <> update.a ...}
#+END_SRC

Third, because Record is kind-of like a row-polymorphic Tuple, and Tuple has a Monoid instance, it should mean that creating a something simmilar for Records should be quite an easy puzzle to solve :-)

** First the memptyRecord

Because I wouldn't be implementing a proper instance (still not entirely sure that is possible just yet in Purescript, would I need overlaping typeclass instance support to do that?), and just the two hepler functions,
that more or less try to convey the implementation of the instance in spirit, I start with the memptyRecord implementation.

It turns out it is easier than the appendRecord one.

For the class itself, I just need the RowList and output row.

#+BEGIN_SRC purescript
class MemptyRecord rl row | rl -> row
  where
    memptyRecordImpl :: RLProxy rl -> Record row
#+END_SRC

And Nil case will be just an empty record.

#+BEGIN_SRC purescript
instance memptyRecordNil :: MemptyRecord Nil () where
  memptyRecordImpl _ = {}
#+END_SRC

In the Cons instance, I just iterate over the ~RowList~, on constraint that every there is a ~Monoid~ in every row and insert a ~mempty~ for that row.

#+BEGIN_SRC purescript
instance memptyRecordCons ::
  ( IsSymbol name
  , Monoid t
  , MemptyRecord tail tailRow
  , RowLacks name tailRow
  , RowCons name t tailRow row
  ) => MemptyRecord (Cons name t tail) row where
  memptyRecordImpl _ =
     insert namep mempty rest
   where
     namep = SProxy :: SProxy name
     tailp = RLProxy :: RLProxy tail
     rest = memptyRecordImpl tailp
#+END_SRC

To tie it all together, I wrap the memptyRecordImpl in memptyRecord function, that makes the compiler to firure out the row-list for me.

#+BEGIN_SRC purescript
memptyRecord :: forall rl row . RowToList row rl
   => MemptyRecord rl row
   => Record row
memptyRecord = memptyRecordImpl (RLProxy :: RLProxy rl)
#+END_SRC

In the end, this was fairly simple and I managed to solve the first problem, because now 

#+BEGIN_SRC purescript
     {a : "", b : 0}  == memptyRecord :: {a :: String, b :: Array Int}
#+END_SRC

This of-course doesn't really work on nested records, but I think it is still an improvement.

** Now, the appendRecord

For the sake of simplicity I will just dump the entirety of my first attempt at this.
It actually worked and ~appendRecord {a: "1", b: [2], c: "3"} {a: "a", b: [4], c: "c"} == {a: "1a", b: [2,4], c: "3c"}~,
but there wasn't nothing new in there.

#+BEGIN_SRC purescript
+class SemigroupRecord rl row row'
  | rl -> row row'
  where
    appendRecordImpl :: RLProxy rl -> Record row -> Record row -> Record row'

instance appendRecordCons ::
  ( IsSymbol name
  , Semigroup ty
  , RowCons name ty trash row
  , SemigroupRecord tail row tailRow'
  , RowLacks name tailRow'
  , RowCons name ty tailRow' row'
  ) => SemigroupRecord (Cons name ty tail) row row' where
  appendRecordImpl _ a b =
      insert namep (valA <> valB) rest
    where
      namep = SProxy :: SProxy name
      valA = get namep a
      valB = get namep b
      rest = appendRecordImpl (RLProxy :: RLProxy tail) a b
 
 instance appendRecordNil :: SemigroupRecord Nil row () where
   appendRecordImpl _ _ _ = {}
#+END_SRC


Thing is, I didn't like it.
