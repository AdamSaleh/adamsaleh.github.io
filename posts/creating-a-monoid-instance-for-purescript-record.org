#+BEGIN_COMMENT
.. title: Creating a Monoid instance for Purescript Record
.. slug: creating-a-monoid-instance-for-purescript-record
.. date: 2018-01-03 09:00:20 UTC+01:00
.. tags: 
.. category: 
.. link: 
.. description: 
.. type: text
#+END_COMMENT

* Ok

** A rationale behind this attempt

Whyy would I want to attempt to create a monoid-like thing for records? Well, the reasoning is three-fold.
First, when playing around with Purescript, I often have these large record definitions and then I have to initialize them. I would much rather just say "This record has all fields empty, figure it out."
Second, these large records are often the heart of some state, that I update all the time, and I would much rather just do

#+BEGIN_SRC purescript
 updateFunction state update = appendRecord state update
#+END_SRC

than

#+BEGIN_SRC purescript
updateFunction state update = state {a = state.a <> update.a ...}
#+END_SRC

Third, because Record is kind-of like a row-polymorphic Tuple, and Tuple has a Monoid instance, it should mean that creating a something simmilar for Records should be quite an easy puzzle to solve :-)

** First the memptyRecord

Because I wouldn't be implementing a proper instance (still not entirely sure that is possible just yet in Purescript, would I need overlaping typeclass instance support to do that?), and just the two hepler functions,
that more or less try to convey the implementation of the instance in spirit, I start with the memptyRecord implementation.

It turns out it is easier than the appendRecord one.

For the class itself, I just need the RowList and output row.

#+BEGIN_SRC purescript
class MemptyRecord rl row | rl -> row
  where
    memptyRecordImpl :: RLProxy rl -> Record row
#+END_SRC

And Nil case will be just an empty record.

#+BEGIN_SRC purescript
instance memptyRecordNil :: MemptyRecord Nil () where
  memptyRecordImpl _ = {}
#+END_SRC

In the Cons instance, I just iterate over the ~RowList~, on constraint that every there is a ~Monoid~ in every row and insert a ~mempty~ for that row.

#+BEGIN_SRC purescript
instance memptyRecordCons ::
  ( IsSymbol name
  , Monoid t
  , MemptyRecord tail tailRow
  , RowLacks name tailRow
  , RowCons name t tailRow row
  ) => MemptyRecord (Cons name t tail) row where
  memptyRecordImpl _ =
     insert namep mempty rest
   where
     namep = SProxy :: SProxy name
     tailp = RLProxy :: RLProxy tail
     rest = memptyRecordImpl tailp
#+END_SRC

To tie it all together, I wrap the memptyRecordImpl in memptyRecord function, that makes the compiler to firure out the row-list for me.

#+BEGIN_SRC purescript
memptyRecord :: forall rl row . RowToList row rl
   => MemptyRecord rl row
   => Record row
memptyRecord = memptyRecordImpl (RLProxy :: RLProxy rl)
#+END_SRC

In the end, this was fairly simple and I managed to solve the first problem, because now 

#+BEGIN_SRC purescript
     {a : "", b : 0}  == memptyRecord :: {a :: String, b :: Array Int}
#+END_SRC

This of-course doesn't really work on nested records, but I think it is still an improvement.

** Now, the appendRecord

For the sake of simplicity I will just dump the entirety of my first attempt at this.
It actually worked and ~appendRecord {a: "1", b: [2], c: "3"} {a: "a", b: [4], c: "c"} == {a: "1a", b: [2,4], c: "3c"}~,
but there wasn't nothing new in there.

#+BEGIN_SRC purescript
+class SemigroupRecord rl row row'
  | rl -> row row'
  where
    appendRecordImpl :: RLProxy rl -> Record row -> Record row -> Record row'

instance appendRecordCons ::
  ( IsSymbol name
  , Semigroup ty
  , RowCons name ty trash row
  , SemigroupRecord tail row tailRow'
  , RowLacks name tailRow'
  , RowCons name ty tailRow' row'
  ) => SemigroupRecord (Cons name ty tail) row row' where
  appendRecordImpl _ a b =
      insert namep (valA <> valB) rest
    where
      namep = SProxy :: SProxy name
      valA = get namep a
      valB = get namep b
      rest = appendRecordImpl (RLProxy :: RLProxy tail) a b
 
 instance appendRecordNil :: SemigroupRecord Nil row () where
   appendRecordImpl _ _ _ = {}
#+END_SRC


This implementation required, that when I use ~appendRecord~, both records have the same keys, and that didn't really fit the record-updating semantics I had in mind.
If I had a large record to update, I don't really want to specify all of the keys, I just want to specify the keys that I want to update.

With this in mind, I went to #purescript on functionalprogramming.slack.com and started asking, if anybody knows how to implement outer join of two records.
If I knew, that you could somehow merge ~{a: 1, b:"b"}~ with ~{b:"b", c:"c"}~ to get ~{a:1, b:"b", c:"c" }~, changing it do ~{a:1, b:"bb", c:"c" }~ should be simple, right? 

Unfortunately, it turns out, doing outer-join with RowLists seems to be hard, mostly ending the conversation about my outer-join ideas with the question "So, why do you actually want to do that?"
After I described the usecase for updating records, @i-am-tom suggested to change the ~appendRecord~ function to allow the second record be a subset of first one. This means that the ~appendRecordImpl~
type becomes ~RLProxy rl -> Record big -> Record small -> Record big~. This makes everything simpler, and @paluh even sent me an implementation in try-purescript TODO.

First interesting thing I have noticed, that with the new class definition, I don't actually need any functional dependencies.
 
#+BEGIN_SRC purescript
class AppendSubrecordImpl rl bigger smaller where
  appendSubrecordImpl :: RLProxy rl -> Record bigger -> Record smaller -> Record bigger
#+END_SRC

Because the iteration happens over the smaller record, in nil case I just return the bigger record.

#+BEGIN_SRC purescript
instance appendSubrecordNil :: AppendSubrecordImpl Nil bigger smaller where
  appendSubrecordImpl _ b s = b
#+END_SRC

And because I know that the result will be the ~Row bigger~, I don't actually need the machinery to build up the output row.

#+BEGIN_SRC purescript
instance appendSubrecordCons ::
  ( IsSymbol name
  , RowCons name t trash smaller
  , RowCons name t trash' bigger
  , Semigroup t
  , AppendSubrecordImpl tail bigger smaller
  ) => AppendSubrecordImpl (Cons name t tail) bigger smaller where
    appendSubrecordImpl _ bigger smaller = modify key modifier rest
      where
        key = SProxy :: SProxy name
        modifier v = v <> get key smaller
        rest = appendSubrecordImpl (RLProxy âˆ· RLProxy tail) bigger smaller
#+END_SRC

